{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\n\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      initialFocus = _ref.initialFocus,\n      containers = _ref.containers;\n\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\n\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n\n  return false;\n}\n\nexport { Features, useFocusTrap };","map":{"version":3,"mappings":"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","names":["createForOfIteratorHelperLoose","_createForOfIteratorHelperLoose","useRef","useEffect","Keys","focusElement","focusIn","Focus","FocusResult","useWindowEvent","useIsMounted","Features","useFocusTrap","container","features","_temp","All","_ref","initialFocus","containers","restoreElement","window","document","activeElement","previousActiveElement","mounted","featuresRestoreFocus","Boolean","RestoreFocus","featuresInitialFocus","InitialFocus","current","contains","First","Error","console","warn","event","TabLock","key","Tab","preventDefault","shiftKey","Previous","Next","WrapAround","Success","FocusLock","allContainers","Set","add","size","previous","toElement","target","HTMLElement","stopPropagation","element","_iterator","_step","done","_container$current","value"],"sources":["C:/Users/Joka24/Desktop/diplom/node_modules/@headlessui/react/dist/hooks/use-focus-trap.esm.js"],"sourcesContent":["import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\n\nvar Features;\n\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\n\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      initialFocus = _ref.initialFocus,\n      containers = _ref.containers;\n\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\n\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n\n  return false;\n}\n\nexport { Features, useFocusTrap };\n"]},"metadata":{},"sourceType":"module"}