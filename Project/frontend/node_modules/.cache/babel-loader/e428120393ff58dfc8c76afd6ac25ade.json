{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\n\nvar RenderStrategy;\n\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\n\nfunction render(_ref) {\n  var props = _ref.props,\n      slot = _ref.slot,\n      defaultTag = _ref.defaultTag,\n      features = _ref.features,\n      _ref$visible = _ref.visible,\n      visible = _ref$visible === void 0 ? true : _ref$visible,\n      name = _ref.name; // Visible always render\n\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n        isStatic = _props$static === void 0 ? false : _props$static,\n        rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n\n    var _props$unmount = props.unmount,\n        unmount = _props$unmount === void 0 ? true : _props$unmount,\n        _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n\n  return _render(props, slot, defaultTag, name);\n}\n\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n\n  if (slot === void 0) {\n    slot = {};\n  }\n\n  var _omit = omit(props, ['unmount', 'static']),\n      _omit$as = _omit.as,\n      Component = _omit$as === void 0 ? tag : _omit$as,\n      children = _omit.children,\n      _omit$refName = _omit.refName,\n      refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n      passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n\n      return cloneElement(resolvedChildren, Object.assign({}, // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n\n  var _loop = function _loop() {\n    var func = _step.value;\n\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\n\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n\n  return clone;\n}\n\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n\n  var clone = Object.assign({}, object);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n\n  return clone;\n}\n\nexport { Features, RenderStrategy, forwardRefWithAs, render };","map":{"version":3,"mappings":"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","names":["objectWithoutPropertiesLoose","_objectWithoutPropertiesLoose","extends","_extends","createForOfIteratorHelperLoose","_createForOfIteratorHelperLoose","Fragment","isValidElement","cloneElement","createElement","forwardRef","match","Features","RenderStrategy","render","_ref","props","slot","defaultTag","features","_ref$visible","visible","name","_render","featureFlags","None","Static","_props$static","isStatic","rest","_match","_props$unmount","unmount","_rest","strategy","Unmount","Hidden","hidden","style","display","tag","_ref2","_omit","omit","_omit$as","as","Component","children","_omit$refName","refName","passThroughProps","refRelatedProps","ref","undefined","resolvedChildren","className","Object","keys","length","Array","isArray","Error","map","line","join","assign","mergeEventFunctions","compact","existingProps","functionsToMerge","clone","_loop","func","_step","value","_Object$assign","event","defaultPrevented","_iterator","done","forwardRefWithAs","component","_component$displayNam","displayName","object","key","keysToOmit","_iterator2","_step2"],"sources":["C:/Users/Joka24/Desktop/diplom/node_modules/@headlessui/react/dist/utils/render.esm.js"],"sourcesContent":["import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\n\nvar Features;\n\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\n\nvar RenderStrategy;\n\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\n\nfunction render(_ref) {\n  var props = _ref.props,\n      slot = _ref.slot,\n      defaultTag = _ref.defaultTag,\n      features = _ref.features,\n      _ref$visible = _ref.visible,\n      visible = _ref$visible === void 0 ? true : _ref$visible,\n      name = _ref.name;\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n        isStatic = _props$static === void 0 ? false : _props$static,\n        rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n\n    var _props$unmount = props.unmount,\n        unmount = _props$unmount === void 0 ? true : _props$unmount,\n        _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n\n  return _render(props, slot, defaultTag, name);\n}\n\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n\n  if (slot === void 0) {\n    slot = {};\n  }\n\n  var _omit = omit(props, ['unmount', 'static']),\n      _omit$as = _omit.as,\n      Component = _omit$as === void 0 ? tag : _omit$as,\n      children = _omit.children,\n      _omit$refName = _omit.refName,\n      refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n      passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n\n      return cloneElement(resolvedChildren, Object.assign({}, // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n\n  var _loop = function _loop() {\n    var func = _step.value;\n\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\n\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n\n  return clone;\n}\n\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n\n  var clone = Object.assign({}, object);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n\n  return clone;\n}\n\nexport { Features, RenderStrategy, forwardRefWithAs, render };\n"]},"metadata":{},"sourceType":"module"}